%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt]{article}

%##################Packages##################################
%\usepackage[notref,notcite]{showkeys} %SHOWS LABELS

\usepackage[latin2]{inputenc}
\usepackage[usenames]{color}
\usepackage{latexsym}
\usepackage{epsf}
\usepackage{epsfig}
%
\usepackage{amssymb,amsmath}
\usepackage{mathrsfs}
\usepackage{empheq}
\usepackage{slashed}
\usepackage{listings}
\usepackage{url}
\usepackage[hidelinks]{hyperref}

\usepackage{graphicx}
\usepackage[font=footnotesize]{caption}
\usepackage{subcaption}
\usepackage{sidecap}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{multicol}
\linespread{1.25}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother




\def\ni{\noindent}
\def\nn{\nonumber \\}
\def\cC{{\cal C}}
\def\cP{{\cal P}}
\def\cR{{\cal R}}
\def\cL{{\cal L}}
\def\cT{{\cal T}}
\def\cW{{\cal W}}
\def\cM{{\cal M}}
\def\cN{{\cal N}}
\def\Z2{{\mathbb Z}_2}
\def\sgn{{\rm sgn}}
\def\pa{\partial}
\def\ud{\mathrm{d}}
\def\dis{\displaystyle}

\newlength{\dinwidth}
\newlength{\dinmargin}
\setlength{\dinwidth}{21.0cm}
\textheight22.7cm \textwidth17.7cm
\setlength{\dinmargin}{\dinwidth}
\addtolength{\dinmargin}{-\textwidth}
\setlength{\dinmargin}{0.5\dinmargin}
\oddsidemargin -2.25cm
\addtolength{\oddsidemargin}{\dinmargin}
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\marginparwidth}{0.9\dinmargin}
\marginparsep 8pt \marginparpush 5pt
\topmargin -57pt
\headheight 12pt
\headsep 30pt
\footskip 24pt



\newcommand{\argmax}{\operatornamewithlimits{argmax}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\lstset{language=Lisp}


\thispagestyle{empty}

\vspace*{15mm}

\begin{center}
{\Large\bf
An Interpreter for a LISP-like Language
}

\vspace*{5mm}

\end{center}
\vspace*{5mm} \noindent
\vskip 0.5cm
\centerline{\bf
Lewis Smith
}
\centerline{
8933715
}

\vskip 5mm
\vskip 5mm
\centerline{\em University of Manchester }
\vskip 5mm

\begin{center}
\textit{
Any sufficiently complex C or FORTRAN program contains a buggy, inconsistent, ad hoc, informally
specified, bug-ridden, slow implementation of half of common lisp.}
\vskip 5mm
\textit{ - Philip Greenspun}
\end{center}


\vskip 20mm
\vskip 20mm
\section*{Abstract}
This report details the design and implementation of a minimal interpreter for a language in the LISP family,
using C++.  The object oriented features of C++ are used to express the datatypes and primitives of the
language in an elegant and self contained way. Since the actions of an interpreter must
be determined at entirely runtime at by the user's input, extensive use must be made of runtime memory
management and polymorphism, which is made clearer and simpler via effective class design and separation of concerns.
%%%%%
%%%%%
\section{ Introduction }
%%%%%
%%%%%

An \textit{interpreter} is a program that directly executes a series of commands, transforming instructions in
the form of source code in a specified language into computer actions. `Real world' interpreters for production languages are generally programs of considerable size and complexity, however if performance is not a priority, a
minimal interpreter can be implemented fairly concisely. Lisp was chosen as the basis language for this interpreter\footnote{Technically speaking, the language implemented is based on lisp rather than being a lisp: it is compliant with neither the common lisp or scheme standards.} due to the conceptual simpicity of it's syntax and semantics, which greatly simplifies the implementation. All of lisps core syntax
can be expressed as follows:
\begin{lstlisting}
(function argument1 argument2 ...)
\end{lstlisting}


which translates to `apply function to arg1, arg2, arg3...'. All lisp commands are \textit{expressions} rather than statements: that is, they all return a value. All lisp objects are \textit{first class}, meaning that they are all treated the same way, and can be passed around, put inside data structures, and passed as arguments to functions.
The simplicity and uniformity of lisp's syntax greatly simplifies the implementation of the parser, making it plausible to write one by hand rather than
using automatic parser generation software such as lexx and yacc, which are generally used for languages with more complex syntax. Classical lisp
also makes use of only a simple compound datatype, the hetereogenous linked list, which is represented as a space separated list enclosed by parentheses. As this is also the format of function calls in lisp, the data structure used
to represent a lisp program being evaluated and the data structure constructed
by that program are the same, a property known as \textit{homoiconicity}.

The functionality of an interpreter can be broken down into a few components, which can be implemented as separated classes:
\begin{enumerate}
\item The representation of language constructs as data structures. Evaluation of the language can be implemented as a method of this class, due to the
equivalence between lisp code and data.
\item The parser, which translates the string representation of a program into the internal representation of that program.
\item The environment, which allows the binding of language values to names
\item The garbage collector, which is responsible for managing the memory usage of the lisp environment.
\end{enumerate}

\section{Design}
\subsection{S-Expressions}
\label{section:sexp}

Lisp code consists of `S-Expressions', or symbolic expressions. An s-expression
is either an \textit{atom}, a singular literal or identifier, or a list of
s-expressions. S expressions are implemented as an abstract class, which the
specialised types of the language (e.g list objects, strings, functions) all
inherit from. The core data structure, the linked list, can then be implemented
as a list of pointers to the abstract base class, using the linked list from the C++ STL.

 S-expressions can be evaluated by simply returning their literal
values for literal types, by looking up a value in a symbol table for identifiers, and by evaluating lists as a function call of the form
(function argument1 argument2 ...). This can be expressed by the concrete
datatypes overriding virtual functions in an class, which allows
the runtime resolution of an expression along the lines of
\begin{lstlisting}[language=C++]
  an_sexp_pointer->eval(env);
\end{lstlisting}
to have the appropriate behaviour resolved at runtime dependent on the actual
type of the object being known to the calling function.

All fields of s-expressions are made const where possible, making all variables
immutable by default in the implemented language. The only way to change a variable is to create a new one. This may not seem terribly efficient, but it
allows some greater flexibility since we can freely pass around and copy s-expression pointers within the builtin functions since we know the underlying objects cannot change, and the management of heap memory is delegated to the garbage collector.

The use of a separate class to manage the memory of all s-expression classes
makes them look somewhat unusual: in particular, lists and user-defined functions all contain pointers to heap assigned memory, but since no s-expression actually \textit{owns} memory, their destructors and copy constructors are all trivial: it is safe to copy an sexp pointer provided it was allocated correctly using the heap class (see section \ref{section:garbage}).

\subsection{Lexing and Parsing}
\label{section:parser}

The lexer and parser classes handle the task of transforming text into s-expression objects. This task is further seperated into lexing and parsing:
the lexer reads a string into a sequence of tokens, optionally storing additional data. For example, when the lexer encounters an opening bracket, it
returns an open-bracket token, but when it encounters  a number it returns a number token, but must additionally provide a means to access the number it just read.
The output of the lexer is fed into the parser, with this functionality built into the parser by simple composition of a lexer within the parser object.

\subsection{Environment and Scopes}
The environment class is the interface between an s-expression and the state of
the current program, for example, the definitions of variables. At it's core
the environment is essentially a wrapper round a hash table of strings to
s expression pointers. The more specialised global env is unique to a running
interpreter, and is also responsible for keeping track of memory using it's enclosed heap class (see section \ref{garbage}).
A notable feature of the global environment is that it is neither movable
nor copyable: this is because the more general env classes, which just contain
a symbol table and not a heap object, need to link back to the main garbage
collector so the heap can keep track of allocations in these scopes. (Separate
scope objects are used to implement lexical closures, where a function captures variables from the environment it was created in). This is implemented by storing a pointer back to the global scope that created the object: this required that the address of the global env never changes once it is created.
This makes sense from a semantic point of view as well: the global environment and garbage collector are unique objects that the runtime depends on, and it
is difficult to imagine a situation where you would need to, say, pass a copy
of the garbage collector object into a function.
\subsection{Garbage Collection}
\label{section:garbage}
Lisp is a garbage collected language, meaning that the responsibility for manually managing heap memory is delegated to the language runtime, rather than
being the responsibility of the programmer as in C++. As such, it is neccesary to manually implement a garbage collector as part of the lisp runtime. This must
track the usage of memory, detecting when a heap block is no longer referenced by anything in the lisp environment and cleaning up such memory as needed.
An object is in use by lisp if it is reachable from the symbol table, directly or indirectly: if no way to reach it exists then it is garbage.

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{memory.png}
  \caption{\textit{
  A cartoon of the operation of mark-and-sweep. The table to the left of the
  figure represents the symbol table. Arrows between objects A and B denote the
  relationship ``A contains a pointer to B''. The red arrows represent the
  path taken by the marking phase: Starting at each name in the symbol table,
  all memory that is reachable from that name is traced out. Objects not
  reachable by these paths are no longer reachable by any part of the runtime,
  and are thus garbage that can be collected in the sweep phase.
  }}
\end{figure}

One option for a garbage-collection like facility that is provided in C++ 11 is reference counting, where an pointer to a object maintains a record of how many
other pointers that are also pointing to the same memory exist in the program, deallocating them when the reference count reaches zero. This is implemented by C++11's
shared pointer class.
Unfortunately, reference counting is not a complete form of garbage collection. In particular, it is able to leak memory if circular references are possible: that is,
if object A contains a pointer to object B, but object B also contains a pointer to object A, then their reference counts will never hit zero even if it is not possible
to reach either A or B. Since Lisp objects can contain pointers to other Lisp objects, this kind of cycle is possible, and a different strategy is necessary.

The simplest garbage collection algorithm that is guaranteed to collect reference cycles is \textit{mark and sweep}. This algorithm has two stages: in the first,
memory that is reachable is marked, by starting from the roots of the memory graph and traversing through it, marking all memory that is reached. After all memory is
marked, all memory in use is swept. Any memory that was not marked can be safely freed. This requires all memory locations used by the interpreter runtime to be
stored somewhere, so that the sweep phase can clean them up later.

The design I chose to implement this is a class that maintains a record of all memory allocated in a lisp context, providing a method, allocate, that can be used to wrap
all calls to new, storing the pointers in an appropriate structure together with a a boolean flag for the mark phase.

The algorithm used is the most straightforward possible implementation of
mark and sweep. This has some performance penalties, but since simplicity and
correctness have been prioritised over performance this was deemed
unimportant. The efficient implementation of automatic garbage collection is
still something of an open problem in language design, as evidenced by the
continuing use of non-garbage collected languages like C++ and C: solving
it is beyond the scope of this project.

\section{Results}

By judicious choice of language target, a language that is powerful enough to
express useful computation has been implemented. The functionality of the
language is demonstrated by two example programs: \textit{tests.lisp} demonstrates all the implemented builitin functions in order, demonstrating that
the interpreter works as designed. \textit{erastothenes.lisp} uses the Sieve of
Erastothenes algorithm to find all the prime numbers less than 1000, demonstrating the use of the provided language to express a non-trivial program.
The garbage collector works, as validated by the use of the memory tracking program \textit{valgrind} on linux and by the memory debugger in visual studio. %%TODO: pictures?

The use of the standard template library data structures simplifies the code.
The standard linked list is used extensively, as this underlies the fundamental
data structure of the language. Maps, or hash tables, are also used: these structures enable fast lookup of values indexed by keys, and are the most efficient way to implement looking up lisp values by strings in the symbol table. They are also used to associate pointer values with a flag holding their
state in the garbage collector. 

There are a few notable omissions from my version of `lisp': the first is that
I only use a single numeric type, a double precision floating point. Floating point numbers are not always desirable due to the possible introduction of floating point errors. All real-world lisps have a full hierarchy of numerical types, as do most programming languages. However, floating points are good enough for most use cases, and having only a single numerical type greatly simplifies the implementation of numerical functions, since they need not handle casts between different representations of number. A minority of
mainstream programming languages also make this trade off, the most prominent being JavaScript.

Another omission is my implementation of lists and the builtin cons function: in a traditional lisp cons does not need a list as the second argument, but can
take anything. A cons onto a non-list object is called a pair or an improper list, and is written as follows:
\begin{lstlisting}

(a . b)

\end{lstlisting}

I did not implement this because it is something of a historical oddity[CITATION NEEDED?] which is rarely particularly useful, and it complicates the implementation of the list type. Clojure, a modern lisp, also
leaves out this feature.

%%CHANGE IF YOU IMPLEMENT THIS IN THE END?
Two features whose absence is less justifiable are functions with variable numbers of arguments and lexical macros. These features are fairly important
parts of lisp, though they are relatively advanced. I left them out because I felt that they were slightly beyond the requirements of this project, though I would include them if I had to extend it in the future. The lack of
variadic functions in particular is slightly ugly since many of the builtin
functions are variadic: the user lacks the ability to define functions like this, making the builtins `magic', which is not a particularly appealing design.

There are a few areas of my implementation where clarity and simplicity was chosen over performance: this was deemed acceptable due to the scope of the project,
but would possibly require changing if the implementation was extended. The
most notable of these are the garbage collector and the parser: both use
explicitly recursive strategies, which lead to clear code, but mean that very large input could cause the program to overflow the stack. I decided that
clarity of code was preferable in the context of the report: if this language
was intended for more serious use, it would probably be preferable to re-write
this without explicit recursion using for loops and/or gotos to avoid growing the stack while parsing.

Overall, however, I feel that this project is a successful demonstration of the principles behind an interpreter, and of effective object-oriented design
\end{document}
